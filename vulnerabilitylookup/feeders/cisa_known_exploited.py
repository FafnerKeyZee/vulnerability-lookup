import json
import logging
import requests

from datetime import datetime
from pathlib import Path
from redis import Redis
from typing import Optional, Dict
from uuid import uuid4

from ..default import get_config
from ..helpers import get_config_feeder, fromisoformat_wrapper


class CISAKnownExploited():
    def __init__(self):
        self._load_logging_config()
        self.logger = logging.getLogger(f'{self.__class__.__name__}')
        self.config = get_config_feeder('cisa_known_exploited')

        if 'level' in self.config:
            self.logger.setLevel(self.config['level'])
        else:
            self.logger.setLevel(get_config('generic', 'loglevel'))

        self.storage = Redis(host=get_config('generic', 'storage_db_hostname'),
                             port=get_config('generic', 'storage_db_port'))

        self.url = 'https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json'

    def _load_logging_config(self):
        cur_path = Path(__file__)
        if not (cur_path.parent / f'{cur_path.stem}_logging.json').exists():
            return
        with (cur_path.parent / f'{cur_path.stem}_logging.json').open() as f:
            log_config = json.load(f)
        logging.config.dictConfig(log_config)

    def cisa_update(self) -> bool:
        last_update: Optional[datetime]
        if _last_update_str := self.storage.hget('last_updates', 'cisa_known_exploited'):
            last_update = fromisoformat_wrapper(_last_update_str.decode())
        else:
            last_update = None

        r = requests.get(self.url)
        try:
            r.raise_for_status()
        except Exception as e:
            self.logger.debug(f'Failed to fetch: {e}')
            return False

        known_exploited_vulnerabilities = r.json()
        current_update = fromisoformat_wrapper(known_exploited_vulnerabilities['dateReleased'])
        if last_update and current_update <= last_update:
            self.logger.debug(f'cisa_known_exploited: already loaded ({current_update})')
            return False

        index_cisa: Dict[str, float] = {}
        for exploited_vuln in known_exploited_vulnerabilities['vulnerabilities']:
            cve_id = exploited_vuln['cveID']
            # do we already have a meta entry for this source?
            if _meta_uuid := self.storage.hget(f'{cve_id}:meta', 'cisa_known_exploited'):
                meta_uuid = _meta_uuid.decode()
            else:
                meta_uuid = str(uuid4())
            self.storage.hset(f'{cve_id}:meta', mapping={'cisa_known_exploited': meta_uuid})
            # No proper identifier for this source, so we use an UUID
            self.storage.hset(f'cisa_known_exploited:{meta_uuid}', mapping=exploited_vuln)
            index_cisa[meta_uuid] = fromisoformat_wrapper(exploited_vuln['dateAdded']).timestamp()

        # We do not store that in the index key as they are meta
        self.storage.zadd('index:cisa_known_exploited', index_cisa)  # type: ignore

        self.storage.hset('last_updates', mapping={'cisa_known_exploited': current_update.isoformat()})
        self.logger.info('Import done.')
        return True
