#!/usr/bin/env python3

from flask import abort
from flask import Blueprint
from flask import flash
from flask import session
from flask import redirect
from flask import render_template
from flask import request
from flask import url_for
from flask_login import current_user  # type: ignore[import-untyped]
from flask_login import login_required
from werkzeug import Response as WerkzeugResponse
from werkzeug.security import generate_password_hash

from vulnerabilitylookup.default import get_config
from website.notifications import notifications
from website.web.bootstrap import db
from website.web.bootstrap import vulnerabilitylookup
from website.lib.user_utils import confirm_token
from website.models import User
from website.web.forms import ProfileForm
from website.web.forms import AccountConfirmationForm
from website.web.forms import AccountRecoveryForm
from website.web.permissions import reporter_permission

user_bp = Blueprint("user_bp", __name__, url_prefix="/user", template_folder="user")


@user_bp.route("/profile", methods=["GET"])
@login_required  # type: ignore[misc]
def form() -> str:
    """Returns the form to edit the current user."""
    user = User.query.filter(User.id == current_user.id).first()
    form = ProfileForm(obj=user)
    form.populate_obj(current_user)
    action = "Edit user"
    head_titles = [action]
    head_titles.append(user.login)
    return render_template(
        "user/edit_user.html",
        action=action,
        head_titles=head_titles,
        form=form,
        user=user,
    )


@user_bp.route("/profile", methods=["POST"])
@login_required  # type: ignore[misc]
def process_form() -> str | WerkzeugResponse:
    """Process the form for the user edition."""
    form = ProfileForm()
    user = User.query.filter(User.id == current_user.id).first()

    if not form.validate():
        return render_template("user/edit_user.html", form=form, user=user)

    form.populate_obj(user)
    if form.password.data:
        user.pwdhash = generate_password_hash(form.password.data)
    db.session.commit()
    flash(
        f"User {form.login.data} successfully updated.",
        "success",
    )
    return redirect(url_for("user_bp.form"))


@user_bp.route("/generate_apikey", methods=["GET"])
@login_required  # type: ignore[misc]
def generate_apikey() -> WerkzeugResponse:
    """Generate an API key for a user."""
    user = User.query.filter(User.id == current_user.id).first()
    if user is None:
        abort(404)
    user.generate_apikey()
    db.session.commit()
    flash("New API key generated.", "success")
    return redirect(url_for("user_bp.form"))


@user_bp.route("/delete_account", methods=["GET"])
@login_required  # type: ignore[misc]
def delete_account() -> WerkzeugResponse:
    """Delete the account of a user."""
    user = User.query.filter(User.id == current_user.id).first()
    if user is None:
        abort(404)
    db.session.delete(user)
    db.session.commit()
    flash("Account deleted.", "success")
    return redirect(url_for("index"))


@user_bp.route("/confirm_account/<string:token>", methods=["GET", "POST"])
def confirm_account(token: str = "") -> str | WerkzeugResponse:
    """
    Confirm the account of a user with the token that the user has received
    previously by email.
    """
    # Check the token
    user, login = None, None
    if token != "":
        login = confirm_token(token)
    if login:
        user = User.query.filter(User.login == login).first()
    if user is None:
        flash("Impossible to activate this account.", "danger")
        return redirect(url_for("user_bp.login"))

    # Management of the Web form
    form = AccountConfirmationForm()

    if request.method == "GET":
        # Asks the user to provide a new password, in the case the token is
        # valid
        if user is not None:
            return render_template("user/account_recovery_set_password.html", form=form)
        else:
            flash("Impossible to activate this account.", "danger")
    else:
        # Update the password of the user (if the token is valid and if the
        # two passwards are equal)
        if form.password1.data == form.password2.data:
            user.pwdhash = generate_password_hash(form.password1.data)
            user.is_confirmed = True
            db.session.add(user)
            db.session.commit()
            flash("Your password has been updated.", "success")
        else:
            flash("Password must be the same.", "danger")
            return render_template("user/account_recovery_set_password.html", form=form)

        if not user.is_two_factor_authentication_enabled:
            session["username"] = user.login
            return redirect(url_for("user_bp.setup_two_factor_auth"))

    return redirect(url_for("user_bp.login"))


@user_bp.route("/account_recovery", methods=["GET", "POST"])
def account_recovery() -> str | WerkzeugResponse:
    """Returns a form for the account recovery.
    The user will have to provide the login of the account to recover. It can
    not be done via email address since an email address is not unique.
    """
    form = AccountRecoveryForm()
    if request.method == "GET":
        return render_template("user/account_recovery.html", form=form)
    else:
        user = User.query.filter(User.login == form.login.data).first()
        if user is None:
            flash(
                "This user does not exist.",
                "danger",
            )
            return redirect(url_for("home_bp.search"))

        # Send the recovery email with the temporary token
        try:
            notifications.account_recovery(user)
        except Exception as error:
            flash(
                f"Problem while sending activation email: {error}",
                "danger",
            )
            return redirect(url_for("home_bp.search"))

        flash("An email with a recovery link has been sent to you.", "success")

    return redirect(url_for("home_bp.search"))


@user_bp.route("/submit", methods=["GET"])
@user_bp.route("/edit/<string:vulnerability_id>", methods=["GET"])
@login_required  # type: ignore[misc]
@reporter_permission.require(http_exception=403)  # type: ignore[misc]
def vulnogram(vulnerability_id: str = "") -> str | WerkzeugResponse:
    """Returns a form from the vulnogram project in order to edit or create a new vulnerability (CVE list v5)."""
    vulnerability = vulnerabilitylookup.get_vulnerability(
        vulnerability_id, with_meta=True
    )
    local_instance_name = get_config("generic", "local_instance_name").lower()
    local_instance_vulnid_pattern = get_config(
        "generic", "local_instance_vulnid_pattern"
    )
    local_instance_vulnid_example = get_config(
        "generic", "local_instance_vulnid_example"
    )
    if vulnerability_id and None is vulnerability:
        flash(f"Nothing found in the database for {vulnerability_id}.", "warning")
        return redirect(url_for("home_bp.search"))
    source = vulnerabilitylookup.get_vulnerability_source(vulnerability_id)
    return render_template(
        "vulnogram/index.html",
        vulnerability_id=vulnerability_id,
        source=source,
        local_instance_name=local_instance_name,
        local_instance_vulnid_pattern=local_instance_vulnid_pattern,
        local_instance_vulnid_example=local_instance_vulnid_example,
    )
