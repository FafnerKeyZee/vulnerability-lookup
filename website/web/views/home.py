#!/usr/bin/env python3

from __future__ import annotations

import logging
import logging.config

from typing import Any

from feedgen.feed import FeedGenerator  # type: ignore[import-untyped]
from flask import (
    Blueprint,
    request,
    render_template,
    flash,
    redirect,
    url_for,
    make_response,
    Response,
)

from werkzeug import Response as WerkzeugResponse

from vulnerabilitylookup.default import get_config
from website.web.bootstrap import vulnerabilitylookup

logging.config.dictConfig(get_config("logging"))


home_bp = Blueprint("home_bp", __name__, url_prefix="/")

local_instance_name = get_config("generic", "local_instance_name").lower()

# #### Web interface ####


@home_bp.route("/", methods=["GET", "POST"])
@home_bp.route("/search", methods=["GET", "POST"])
def search() -> str | WerkzeugResponse:
    if request.method == "HEAD":
        # Just returns ack if the webserver is running
        return "Ack"
    if request.method == "GET":
        vulnerability_id = request.args.get("vulnerability_id")
        vendor = request.args.get("vendor")
        product = request.args.get("product")
    if request.method == "POST":
        vulnerability_id = None
        product = None
        vendor = None
        # trigger search
        if search_query := request.form.get("freetext_search"):  # Normal search
            vulnerability_id = search_query
        elif search_query := request.form.get(
            "vendor_vuln"
        ):  # Vuln id search from vendor
            vulnerability_id = search_query
            vendor = request.form.get("vendor")
        elif search_query := request.form.get(
            "product"
        ):  # Search for all vulns related to this vendor and product
            product = search_query
            vendor = request.form.get("vendor")

    if vulnerability_id:
        if vulnerabilitylookup.get_vulnerability(vulnerability_id, with_meta=True):
            # The search query was a vulnerability ID, just display that.
            return redirect(
                url_for("home_bp.vulnerability_view", vulnerability_id=vulnerability_id)
            )

        elif linked_vulns := vulnerabilitylookup.get_linked_vulnerabilities(
            vulnerability_id
        ):
            # unable to find a vulnerability with that id. Attempt to find linked entries.
            return render_template(
                "search.html",
                vulnerability_id=vulnerability_id,
                linked_vulns=linked_vulns,
            )
        elif vulnerability_id in vulnerabilitylookup.get_vendors():
            # FIXME: this is dirty.
            vendor = vulnerability_id
            # Got a vendor, show the proper template.
            vendor_products = vulnerabilitylookup.get_vendor_products(vendor)
            vendor_vulns = vulnerabilitylookup.get_vendor_vulnerabilities(vendor)
            return render_template(
                "search.html",
                vendor=vendor,
                vendor_products=vendor_products,
                vendor_vulns=vendor_vulns,
            )
        flash(f"Nothing found in the database for {vulnerability_id}.", "warning")
    elif vendor and not product:
        if vendor in vulnerabilitylookup.get_vendors():
            # Got a vendor, show the proper template.
            vendor_products = vulnerabilitylookup.get_vendor_products(vendor)
            vendor_vulns = vulnerabilitylookup.get_vendor_vulnerabilities(vendor)
            return render_template(
                "search.html",
                vendor=vendor,
                vendor_products=vendor_products,
                vendor_vulns=vendor_vulns,
            )
        else:
            flash(f"Nothing found in the database for {vendor}.", "warning")
    elif vendor and product:
        if vulnerabilities := vulnerabilitylookup.get_vendor_product_vulnerabilities(
            vendor, product
        ):
            return render_template(
                "search.html",
                vendor=vendor,
                product=product,
                vp_vulnerabilities=vulnerabilities,
            )
        else:
            flash(f"Nothing found in the database for {vendor} / {product}.", "warning")

    # render search page
    return render_template("search.html")


@home_bp.route("/recent", methods=["GET"])
@home_bp.route("/recent/<int:page>", methods=["GET"])
def recent(page: int = 1) -> str:
    # For the webinterface, we want the most recent entries by source
    source_to_show = [
        "github",
        "cvelistv5",
        "pysec",
        "gsd",
        "ossf_malicious_packages",
        "csaf_certbund",
        "csaf_siemens",
        "csaf_redhat",
        "csaf_cisa",
        "csaf_cisco",
        "csaf_sick",
        "csaf_nozominetworks",
        "csaf_ox",
        "variot",
        local_instance_name,
    ]
    default_source = "cvelistv5"
    recent = {
        source: vulnerabilitylookup.get_last(source, page=page)
        for source in source_to_show
    }
    try:
        p = int(page)
        if p < 1:
            page = 1
    except ValueError:
        page = 1
    return render_template(
        "recent.html", recent=recent, default_source=default_source, current_page=page
    )


@home_bp.route("/cve/<string:vulnerability_id>", methods=["GET"])
@home_bp.route("/vuln/<string:vulnerability_id>", methods=["GET"])
def vulnerability_view(vulnerability_id: str) -> str:
    if vulnerability := vulnerabilitylookup.get_vulnerability(
        vulnerability_id, with_meta=True
    ):
        # The search query was a vulnerability ID, just display that.
        source = vulnerabilitylookup.get_vulnerability_source(vulnerability_id)
        linked_vulns = vulnerabilitylookup.get_linked_vulnerabilities(vulnerability_id)
        return render_template(
            "vuln.html",
            source=source,
            vulnerability_id=vulnerability_id,
            vulnerability_data=vulnerability,
            linked_vulns=linked_vulns,
        )

    flash(f"Nothing found in the database for {vulnerability_id}.", "warning")
    return render_template("search.html")


@home_bp.route("/recent/<string:source>.<string:format>", methods=["GET"])
def feed_recent(format: str = "atom", source: str = "all") -> Response:
    length: int = int(request.args.get("length", 30))
    public_domain = get_config("generic", "public_domain")
    fg = FeedGenerator()
    fg.id(f"https://{public_domain}/rss/recent/{source}/{length}")
    fg.title(f"Most recent entries from {source}")
    fg.author({"name": "Vulnerability Lookup"})
    fg.link(href=f"https://{public_domain}", rel="alternate")
    # fg.logo('http://ex.com/logo.jpg')
    fg.subtitle(f"Contains only the most {length} recent entries.")
    fg.language("en")
    if source == "all":
        source = ""
    for vuln_id, entry in vulnerabilitylookup.get_last(source, page=1, number=length):
        fe = fg.add_entry()
        fe.id(f"https://{public_domain}/vuln/{vuln_id}")
        fe.title(vuln_id)
        fe.link(href=f"https://{public_domain}/vuln/{vuln_id}")
        if source in ["github", "pysec", "ossf_malicious_packages"]:
            fe.content(entry["details"])
        elif source == "cvelistv5" and "title" in entry["containers"]["cna"]:
            fe.content(entry["containers"]["cna"]["title"])
        else:
            pass
        fe.description()
    if format == "atom":
        feed = fg.atom_str(pretty=True)
    else:
        feed = make_response(fg.rss_str(pretty=True))
        feed.mimetype = "application/rss+xml"
        feed.headers["Content-Type"] = "application/rss+xml"
    return feed
