#!/usr/bin/env python3

import json
import logging

from collections import defaultdict
from typing import Optional, Any, Dict, List, Tuple, Set

from redis import ConnectionPool, Redis
from redis.connection import UnixDomainSocketConnection

from .default import get_config, get_socket_path


class VulnerabilityLookup():

    def __init__(self) -> None:
        self.logger = logging.getLogger(f'{self.__class__.__name__}')
        self.logger.setLevel(get_config('generic', 'loglevel'))

        self.redis_pool: ConnectionPool = ConnectionPool(connection_class=UnixDomainSocketConnection,
                                                         path=get_socket_path('cache'), decode_responses=True)

        self.redis_pool_storage: ConnectionPool = ConnectionPool(
            host=get_config('generic', 'storage_db_hostname'),
            port=get_config('generic', 'storage_db_port'),
            decode_responses=True)

    @property
    def storage(self):
        return Redis(connection_pool=self.redis_pool_storage)

    @property
    def redis(self):
        return Redis(connection_pool=self.redis_pool)

    def check_redis_up(self):
        return self.redis.ping()

    def get_vulnerability_meta(self, vulnerability_id: str) -> Dict[str, Dict[str, Any]]:
        to_return: Dict[str, Dict[str, Any]] = {}
        for meta_name, meta_uuid in self.storage.hgetall(f'{vulnerability_id}:meta').items():
            if meta := self.storage.hgetall(f'{meta_name}:{meta_uuid}'):
                to_return[meta_name] = meta
            else:
                self.logger.warning(f'Unable to find meta {meta_uuid} for {meta_name}')
        return to_return

    def get_linked_vulnerabilities(self, vulnerability_id: str) -> Dict[str, List[Tuple[str, Dict[str, Any]]]]:
        to_return: Dict[str, List[Tuple[str, Dict[str, Any]]]] = defaultdict(list)
        for linked_vuln in self.storage.smembers(f'{vulnerability_id}:link'):
            if vuln := self.get_vulnerability(linked_vuln):
                if source := self.get_vulnerability_source(linked_vuln):
                    to_return[source].append((linked_vuln, vuln))
                else:
                    self.logger.warning(f'Unable to find source for {linked_vuln}')
        return to_return

    def get_vulnerability_source(self, vulnerability_id: str) -> Optional[str]:
        for source in self.storage.hkeys('last_updates'):
            if self.storage.zscore(f'index:{source}', vulnerability_id):
                return source
        return None

    def get_vulnerability(self, vulnerability_id: str,
                          *, with_meta: Optional[bool]=False) -> Optional[Dict[str, Any]]:
        _vuln = self.storage.get(vulnerability_id)
        if not _vuln:
            return None
        vuln = json.loads(_vuln)
        if with_meta:
            if meta := self.get_vulnerability_meta(vulnerability_id):
                vuln['meta'] = meta
        return vuln

    def get_sources(self) -> Set[str]:
        last_updates = self.storage.hgetall('last_updates')
        return {name for name in last_updates.keys()}

    def del_source(self, source: str) -> bool:
        return self.storage.hdel('last_updates', source)

    def get_info(self):
        last_updates = self.storage.hgetall('last_updates')

        sizes = {name: self.storage.zcard(f'index:{name}') for name in last_updates.keys()}
        sizes['total'] = self.storage.zcard('index')

        return {'last_updates': last_updates, 'db_sizes': sizes}

    def get_last(self, source: Optional[str]=None, number: Optional[int]=30):
        key = 'index'
        if source:
            key = f'{key}:{source}'
        if not number:
            number = 30
        to_return = []
        for vunl_id in self.storage.zrevrangebyscore(key, '+Inf', '-Inf', start=0, num=number):
            if vuln := self.get_vulnerability(vunl_id):
                to_return.append(vuln)
        return to_return

    def get_all(self, source: str, /):
        """This method will scan a complete source and yield the vulnerabilities.
        It is up to the caller to handle the yielded entries as it will be a lot"""
        for vuln_id, _ in self.storage.zscan_iter(f'index:{source}'):
            if vuln := self.get_vulnerability(vuln_id):
                yield vuln

    def get_vendors(self):
        return self.storage.smembers('vendors')

    def get_vendor_products(self, vendor: str):
        return self.storage.smembers(f'{vendor}:products')

    def get_vendor_vulnerabilities(self, vendor: str):
        return self.storage.smembers(f'{vendor}:vulnerabilities')

    def get_vendor_product_vulnerabilities(self, vendor: str, product: str):
        to_return: Dict[str, List[Tuple[str, Dict[str, Any]]]] = defaultdict(list)
        for vuln_id in self.storage.smembers(f'{vendor}:{product}:vulnerabilities'):
            if vuln := self.get_vulnerability(vuln_id):
                if source := self.get_vulnerability_source(vuln_id):
                    to_return[source].append((vuln_id, vuln))
                else:
                    self.logger.warning(f'Unable to find source for {vuln_id}')
        return to_return
