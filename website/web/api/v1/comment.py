from typing import Any
from typing import Dict
from typing import Tuple
from datetime import datetime

import logging
from flask_login import current_user  # type: ignore[import-untyped]
from flask_restx import fields
from flask_restx import abort  # type: ignore[import-untyped]
from flask_restx import Namespace
from flask_restx import reqparse
from flask_restx import Resource

from website.web.bootstrap import db
from website.validators import validate_json
from website.web.api.v1.common import auth_func
from website.web.api.v1.types import ResultType
from website.models.comment import Comment
from website.web.permissions import admin_permission, commenter_permission

logger = logging.getLogger(__name__)

comment_ns = Namespace("comment", description="comment related operations")

# Argument Parsing
parser = reqparse.RequestParser()
parser.add_argument("vuln_id", type=str, help="ID of the vulnerability.")


# Response marshalling
metada_params_model = {
    "count": fields.String(
        readonly=True, description="Total number of the items of the data."
    ),
    "offset": fields.String(
        readonly=True,
        description="Position of the first element of the data from the total data amount.",
    ),
    "limit": fields.String(readonly=True, description="Requested limit data."),
}

comment_params_model = {
    "id": fields.String(description="Comment id.", readonly=True),
    "author_id": fields.Integer(description="Id of the author."),
    "updated_at": fields.DateTime(
        description="Updated time of the comment.", readonly=True
    ),
    "data": fields.Raw(description="The JSON data."),
}
comment = comment_ns.model("Comment", comment_params_model)
metadata = comment_ns.model("metadata", metada_params_model)

comment_list_fields = comment_ns.model(
    "CommentsList",
    {
        "metadata": fields.Nested(
            metadata, description="Metada related to the result."
        ),
        "data": fields.List(fields.Nested(comment), description="List of comments."),
    },
)


@comment_ns.route("/comment/<string:comment_id>")
class CommentItem(Resource):  # type: ignore[misc]
    @comment_ns.doc(description="Get a comment.")  # type: ignore[misc]
    @comment_ns.marshal_list_with(comment_list_fields)  # type: ignore[misc]
    def get(self, comment_id: str) -> Tuple[dict[str, str], int]:
        results = Comment.query.filter(Comment.id == comment_id)
        result: ResultType = {
            "data": results.all(),
            "metadata": {
                "count": results.count(),
                "offset": 0,
                "limit": 10,
            },
        }
        return result, 200

    @comment_ns.doc(description="Delete a comment.")  # type: ignore[misc]
    @admin_permission.require(http_exception=403)  # type: ignore[misc]
    @auth_func
    def delete(self, comment_id: str) -> Tuple[dict[Any, Any], int]:
        """Endpoint for deleting a comment."""
        obj = Comment.query.filter(Comment.id == comment_id).first()
        if obj:
            if not current_user.is_admin and current_user.id != obj.author_id:
                return abort(403, "You cannot delete this comment.")
            db.session.delete(obj)
            db.session.commit()
        return {}, 204


@comment_ns.route("/comment/")
class CommentsList(Resource):  # type: ignore[misc]
    @comment_ns.doc("list_comments")  # type: ignore[misc]
    @comment_ns.expect(parser)  # type: ignore[misc]
    @comment_ns.marshal_list_with(comment_list_fields)  # type: ignore[misc]
    def get(self) -> Tuple[Dict[Any, Any], int]:
        """List all comments."""
        args = parser.parse_args()
        offset = args.pop("page", 1) - 1
        limit = args.pop("per_page", 10)
        vuln_id = args.pop("vuln_id", None)

        result: ResultType = {
            "data": [],
            "metadata": {
                "count": 0,
                "offset": offset,
                "limit": limit,
            },
        }

        results = []
        count = 0
        query = Comment.query
        if vuln_id is not None:
            query = query.filter(Comment.vuln_id.ilike("%" + vuln_id + "%"))

        query = query.order_by(Comment.created_at.desc())
        total = query.count()
        query = query.limit(limit)
        results = query.offset(offset * limit)
        count = total

        result["data"] = results
        result["metadata"]["count"] = count

        return result, 200

    @comment_ns.doc(description="Create a comment related to a security advisory.")  # type: ignore[misc]
    @comment_ns.doc(
        responses={
            200: "Success.",
            400: "JSON validation failed.",
            403: "Commenter permission required.",
        }
    )  # type: ignore[misc]
    @commenter_permission.require(http_exception=403)  # type: ignore[misc]
    @auth_func
    def post(self) -> Tuple[Dict[Any, Any], int]:
        """Create a new comment related to a security advisory (vulnerability)."""
        # Validate the JSON payloadi
        current_time = datetime.now()
        vuln_id = comment_ns.payload["json_object"]["vulnerability"]
        comment = comment_ns.payload["json_object"]
        comment["creation_timestamp"] = current_time.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        comment["timestamp"] = current_time.strftime("%Y-%m-%dT%H:%M:%S.%fZ")
        try:
            validate_json(comment, "circl_comment")
        except Exception:
            logger.warning("JSON validation failed.")
            abort(400, "JSON validation failed.")

        print(comment)

        new_comment = Comment(
            vuln_id=vuln_id,
            data=comment,
            is_published=True if current_user.is_admin else False,
            author_id=current_user.id,
            created_at=current_time,
            updated_at=current_time,
        )
        db.session.add(new_comment)
        db.session.commit()

        return comment, 200
