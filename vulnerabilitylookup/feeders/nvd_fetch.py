import json
import logging
import requests

from datetime import datetime, timedelta
from pathlib import Path
from redis import Redis
from typing import Optional, Dict, Union

from ..default import get_config
from ..helpers import get_config_feeder, fromisoformat_wrapper


class NVDFetcher():
    def __init__(self):
        self._load_logging_config()
        self.logger = logging.getLogger(f'{self.__class__.__name__}')
        self.config = get_config_feeder('nvd')
        if 'apikey' in self.config:
            self.url_apikey_param = {"apiKey": self.config['apikey']}
        else:
            self.url_apikey_param = {}

        if 'level' in self.config:
            self.logger.setLevel(self.config['level'])
        else:
            self.logger.setLevel(get_config('generic', 'loglevel'))

        self.storage = Redis(host=get_config('generic', 'storage_db_hostname'),
                             port=get_config('generic', 'storage_db_port'))

        self.url_api = "https://services.nvd.nist.gov/rest/json/cves/2.0/?"

    def _load_logging_config(self):
        cur_path = Path(__file__)
        if not (cur_path.parent / f'{cur_path.stem}_logging.json').exists():
            return
        with (cur_path.parent / f'{cur_path.stem}_logging.json').open() as f:
            log_config = json.load(f)
        logging.config.dictConfig(log_config)

    def nvd_update(self) -> bool:
        query: Dict[str, Union[int, str]]
        last_update: Optional[datetime]
        if _last_update_str := self.storage.hget('last_updates', 'nvd'):
            last_update = fromisoformat_wrapper(_last_update_str.decode())
        else:
            last_update = None
        if last_update is None:
            query = {}
        else:
            query = {'lastModStartDate': (last_update - timedelta(hours=10)).isoformat(),
                     'lastModEndDate': (datetime.now() - timedelta(seconds=10)).isoformat()
                     }

        last_update = datetime.now()
        self.logger.debug(f'nvd_query: {query}')

        index = 0
        totalResults = None
        results_per_page = None
        max_results_per_page = 50
        while True:
            query['startIndex'] = index
            query['resultsPerPage'] = max_results_per_page
            r = requests.get(self.url_api, params=query, headers=self.url_apikey_param)
            r.raise_for_status()
            nvd_value = r.json()
            if totalResults is None:
                totalResults = nvd_value["totalResults"]
                self.logger.debug(totalResults)
            results_per_page = len(nvd_value['vulnerabilities'])
            if not results_per_page:
                # No more CVEs
                break
            self.logger.debug(f"index:{index} totalResults:{totalResults}")
            index += results_per_page
            # Store all cves individually
            p = self.storage.pipeline()
            cves: Dict[str, float] = {}
            for vuln in nvd_value['vulnerabilities']:
                p.set(vuln['cve']['id'], json.dumps(vuln))
                cves[vuln['cve']['id']] = fromisoformat_wrapper(vuln['cve']['lastModified']).timestamp()
            p.zadd('index:nvd', cves)  # type: ignore
            p.zadd('index', cves)  # type: ignore

            # Just load CPE for testing
            if 'configurations' in vuln['cve']:
                for configuration in vuln['cve']['configurations']:
                    if 'nodes' not in configuration:
                        continue
                    for node in configuration['nodes']:
                        if 'cpeMatch' not in node:
                            continue
                        for cpematch in node['cpeMatch']:
                            if 'criteria' in cpematch:
                                _, _, _, vendor, product, _ = cpematch['criteria'].split(':', 5)
                                p.sadd('vendors', vendor)
                                p.sadd(f'{vendor}:products', product)
                                p.sadd(f'{vendor}:vulnerabilities', vuln['cve']['id'])
                                p.sadd(f'{vendor}:{product}:vulnerabilities', vuln['cve']['id'])

            p.execute()
            if results_per_page < max_results_per_page:
                break
        self.storage.hset('last_updates', mapping={'nvd': last_update.isoformat()})
        self.logger.info('Import done.')
        return True
