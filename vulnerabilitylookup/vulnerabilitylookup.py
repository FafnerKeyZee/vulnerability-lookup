#!/usr/bin/env python3

import json
import logging

from collections import defaultdict
from typing import Optional, Any, Dict, List

from redis import ConnectionPool, Redis
from redis.connection import UnixDomainSocketConnection

from .default import get_config, get_socket_path


class VulnerabilityLookup():

    def __init__(self) -> None:
        self.logger = logging.getLogger(f'{self.__class__.__name__}')
        self.logger.setLevel(get_config('generic', 'loglevel'))

        self.redis_pool: ConnectionPool = ConnectionPool(connection_class=UnixDomainSocketConnection,
                                                         path=get_socket_path('cache'), decode_responses=True)

        self.redis_pool_storage: ConnectionPool = ConnectionPool(
            host=get_config('generic', 'storage_db_hostname'),
            port=get_config('generic', 'storage_db_port'),
            decode_responses=True)

    @property
    def storage(self):
        return Redis(connection_pool=self.redis_pool_storage)

    @property
    def redis(self):
        return Redis(connection_pool=self.redis_pool)

    def check_redis_up(self):
        return self.redis.ping()

    def get_linked_vulnerabilities(self, vulnerability_id) -> Dict[str, List[Dict[str, Any]]]:
        to_return: Dict[str, List[Dict[str, Any]]] = defaultdict(list)
        for linked_vuln in self.storage.smembers(f'{vulnerability_id}:link'):
            if vuln := self.get_vulnerability(linked_vuln):
                source = self.get_vulnerability_source(linked_vuln)
                if source:
                    # TODO: Should always be the case, add a warning if not
                    to_return[source].append(vuln)
        return to_return

    def get_vulnerability_source(self, vulnerability_id) -> Optional[str]:
        for source in self.storage.hkeys('last_updates'):
            if self.storage.zscore(f'index:{source}', vulnerability_id):
                return source
        return None

    def get_vulnerability(self, vulnerability_id) -> Optional[Dict[str, Any]]:
        _vuln = self.storage.get(vulnerability_id)
        if _vuln:
            return json.loads(_vuln)
        return None

    def get_info(self):
        last_updates = self.storage.hgetall('last_updates')

        sizes = {name: self.storage.zcard(f'index:{name}') for name in last_updates.keys()}
        sizes['total'] = self.storage.zcard('index')

        return {'last_updates': last_updates, 'db_sizes': sizes}

    def get_last(self, source: Optional[str]=None, number: Optional[int]=30):
        key = 'index'
        if source:
            key = f'{key}:{source}'
        if not number:
            number = 30
        to_return = []
        for vunl_id in self.storage.zrevrangebyscore(key, '+Inf', '-Inf', start=0, num=number):
            to_return.append(self.get_vulnerability(vunl_id))
        return to_return

    def get_vendors(self):
        return self.storage.smembers('vendors')

    def get_vendor_products(self, vendor: str):
        return self.storage.smembers(f'{vendor}:products')

    def get_vendor_vulnerabilities(self, vendor: str):
        return self.storage.smembers(f'{vendor}:vulnerabilities')

    def get_vendor_product_vulnerabilities(self, vendor: str, product: str):
        to_return = []
        for vunl_id in self.storage.smembers(f'{vendor}:{product}:vulnerabilities'):
            to_return.append(self.get_vulnerability(vunl_id))
        return to_return
